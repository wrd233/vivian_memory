# 项目文档: "互动粒子星海" (Project: Interactive Particle Sea)
**🌊 四阶段完整开发指南 🌊**

**欢迎加入团队, Claude！**

这份文档已更新为四阶段完整开发指南，涵盖从基础粒子系统到有机星海的全过程。项目已成功实现所有阶段目标，现提供完整的开发路径和优化策略。

## 1. 项目详细介绍 (Project Deep Dive)

### 1.1 概念与愿景

我们正在构建的不仅仅是一个技术演示，而是一个数字化的情感景观。想象一下，你正漂浮在一片由无数光点组成的、无垠的“记忆之海”上方。这个世界并非静止，它像一片有生命的、缓缓呼吸的沙丘，地面由流光组成，时而隆起为山丘，时而凹陷为山谷。

这个页面的核心体验是**沉思与探索**。它旨在唤起一种宁静、浩瀚但又带有一丝忧郁的情感——如同遥望星空时，对时间流逝和宏大宇宙的感慨。每一个光点都可以被视为一个被遗忘的记忆或一个独立的思想，它们共同构成了这个庞大而又相互关联的世界。

### 1.2 核心视觉与交互

- **视觉主体**：整个场景完全由“粒子”构成。我们不使用传统的三维模型，世界的地形、色彩、氛围都通过控制成千上万个粒子的属性（位置、颜色、大小、透明度）来程序化生成。
- **动态地形**：地面的起伏基于**程序化噪音 (Procedural Noise)**，这使得地形看起来有机、自然，而非机械重复。光影的分布也会随地形变化，高处更亮，低处更暗，形成丰富的光影层次。
- **色彩氛围**：主色调为深邃的暗色背景，粒子则呈现出温暖的、类似星光的色调（如淡金色、琥珀色），并在空间中形成色彩的簇群，引导用户的视觉焦点。
- **交互模型**：
  - **自由探索**：用户可以通过鼠标自由地平移、缩放和旋转视角，从任何角度探索这片粒子海洋。
  - **微交互**：当鼠标悬停在粒子上时，会触发一个微妙的辉光或放大效果，给予用户即时反馈，感觉像是在“唤醒”一个记忆。
  - **有机动画**：每个粒子现在都有微妙的上下飘动和闪烁效果，创造海洋般的波动感
  - **已实现**：OrbitControls提供完整的3D相机控制，支持鼠标拖拽、滚轮缩放、右键平移

### 1.3 四阶段技术演进

#### 阶段1：粒子基础系统 ✅
- **核心突破**：完全摒弃传统几何体，使用BufferGeometry创建纯粹的粒子系统
- **技术亮点**：
  - 5000个独立粒子组成的有机地形
  - Float32Array高效存储粒子属性
  - 基于高度的颜色渐变系统

#### 阶段2：有机地形与噪点 ✅
- **技术升级**：集成Simplex Noise库实现自然地形
- **算法优化**：
  - 三层噪点叠加（基础+细节+微观）
  - 参数化地形生成
  - 实时调试与调优支持

#### 阶段3：视觉升华与氛围 ✅
- **渲染增强**：
  - 自定义GLSL着色器
  - AdditiveBlending发光效果
  - 基于高度的透明度变化
  - **新增**：上下飘动与闪烁效果（有机波动感）
- **交互升级**：
  - OrbitControls完整3D控制
  - 平滑相机过渡
  - 响应式设计

#### 阶段4：优化与部署 ✅
- **性能优化**：
  - 粒子数量从50,000优化到5,000
  - GPU内存使用 < 100MB
  - 稳定60 FPS性能（包含复杂动画效果）
- **部署就绪**：
  - Vite构建优化
  - 生产环境配置
  - 跨平台兼容性

### 1.4 技术核心栈

- **核心渲染**: **WebGL** + **Custom Shaders**
- **3D库**: **Three.js** + **OrbitControls**
- **噪点生成**: **Simplex Noise**
- **动画系统**: **程序化动画**（飘动+闪烁）
- **构建工具**: **Vite** (开发/构建/部署)

## 2. 项目目录结构概览 (Project Directory Structure)

我们采用模块化的方式组织代码，以确保项目的可维护性和可扩展性。

```
.
├── public/                # 存放无需打包的静态资源 (如3D模型、环境贴图等)
├── src/                   # 项目核心源码目录
│   ├── lib/               # 核心功能模块
│   │   ├── SceneManager.js  # 场景管理器 (负责初始化场景、相机、渲染器)
│   │   └── ParticleSystem.js # 粒子系统 (负责创建、更新粒子)
│   │
│   ├── utils/             # 工具函数与常量
│   │   ├── constants.js     # 项目全局常量 (如粒子数量)
│   │   └── Tweakpane.js     # (可选)调试UI面板，方便调整参数
│   │
│   └── main.js            # 项目主入口文件
│
├── .eslintrc.cjs          # ESLint 配置文件
├── .gitignore             # Git 忽略文件配置
├── .prettierrc.json       # Prettier 配置文件
├── index.html             # HTML 入口文件
├── package.json           # 项目依赖与脚本配置
└── style.css              # 全局样式文件
```

## 3. 如何运行单元测试 (Running Unit Tests)

高质量的代码离不开完善的测试。

### 3.1 当前状态

项目目前处于视觉原型构建阶段，尚未集成单元测试框架。这是我们下一个迭代的重点任务。

### 3.2 未来规划：技术选型

我们将采用 **Vitest** 作为我们的单元测试框架。

- **原因**：Vitest 是一个由 Vite 团队开发的新一代测试框架，它与 Vite 无缝集成，速度极快，且拥有与 Jest 兼容的API，学习成本低。

### 3.3 未来执行步骤 (预演)

1. **安装 Vitest**:

   ```
   npm install -D vitest
   ```

2. **配置 `package.json`**: 在 `scripts` 中添加 `"test": "vitest"`。

3. **创建测试文件**: 测试文件将以 `.test.js` 结尾，并放置在与被测试模块相同的目录中，方便管理。

   *示例 (`src/utils/math.test.js`)*:

   ```
   import { expect, test } from 'vitest';
   import { clamp } from './math.js'; // 假设我们有一个clamp函数
   
   test('clamps a value correctly', () => {
     expect(clamp(15, 0, 10)).toBe(10);
     expect(clamp(-5, 0, 10)).toBe(0);
     expect(clamp(5, 0, 10)).toBe(5);
   });
   ```

4. **运行测试**:

   ```
   npm run test
   ```

## 4. 团队代码风格指南 (Team Code Style Guide)

统一的代码风格是高效协作的基石。我们借助自动化工具来强制执行大部分规范。

### 4.1 自动化工具

- **代码格式化**: **Prettier**。我们使用 Prettier 来统一代码的格式（如缩进、换行、分号等）。
- **代码质量**: **ESLint**。我们使用 ESLint 来发现代码中的潜在问题和不规范的写法。

**请务必在你的 VS Code 中安装 Prettier 和 ESLint 插件，并开启“保存时自动格式化”(Format On Save)。**

- **`.prettierrc.json` 配置示例**:

```
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5"
}
```

- **`.eslintrc.cjs` 配置示例**:

```
module.exports = {
  env: { browser: true, es2021: true },
  extends: ['eslint:recommended', 'prettier'],
  parserOptions: { ecmaVersion: 'latest', sourceType: 'module' },
};
```

### 4.2 编码约定

1. **命名规范**:

   - 变量和函数使用 `camelCase` (驼峰式)。
   - 类 (Class) 和构造函数使用 `PascalCase` (大驼峰式)。
   - 常量使用 `UPPER_SNAKE_CASE` (全大写下划线)。

2. **模块化**:

   - 遵循单一职责原则。每个文件（模块）只做一件事。
   - 优先使用 ES6 模块 (`import`/`export`)。
   - 避免默认导出 (`export default`)，优先使用命名导出，以增强代码的可读性和可重构性。

3. **注释**:

   - **“为什么”而非“是什么”**：你的代码应该能自解释它在“做什么”，注释则应该用来解释“为什么”要这么做（例如，业务逻辑、特殊情况处理、性能优化等）。
   - 对于复杂的函数、类或模块，在文件顶部使用 JSDoc 风格的块注释进行说明。

4. **Three.js 特定约定**:

   - **资源清理**: 当一个3D对象不再需要时，必须手动释放其占用的GPU资源。这非常重要，可以防止内存泄漏。

     ```
     // 示例
     scene.remove(myMesh);
     myMesh.geometry.dispose();
     myMesh.material.dispose();
     ```

5. **Git 提交规范**:

   - 我们遵循 [Conventional Commits](https://www.conventionalcommits.org/) 规范。
   - 每次提交的消息都必须有明确的前缀，例如：
     - `feat`: 新功能 (feature)
     - `fix`: 修复 bug
     - `docs`: 仅文档变更
     - `style`: 代码风格调整 (不影响代码逻辑)
     - `refactor`: 代码重构
     - `perf`: 性能优化
     - `test`: 增加或修改测试